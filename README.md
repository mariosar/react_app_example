# REACT APP EXAMPLE

A React app created without create-react-app that will be used to communicate with my [Rails Api](https://github.com/mariosar/api_example/)

## Steps to reproduce project

```
mkdir react_app_example && cd react_app_example
yarn init -y
yarn add react react-dom
```

Initialize our repository, but first create a .gitignore:
```
touch .gitignore

# .gitignore
node_modules

# Generated by webpack during compiliation process. Does not need to be committed. Will be generated in production during compilation.
dist
```

## Hello World Example
```
mkdir -p src/public && touch src/index.js src/index.css src/public/index.html

# index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>React App</title>
</head>
<body>
  <div id="app"></div> 
</body>
</html>

# src/index.js

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';

class App extends React.Component{
    render(){
        return(
            <div>Hello World</div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('app'))
```

## Dev Dependencies
```
yarn add -D @babel/core @babel/preset-env @babel/preset-react
yarn add -D webpack webpack-cli webpack-dev-server babel-loader css-loader style-loader html-webpack-plugin
yarn add -D http-server
```

# http-server
> `http-server` is a simple, zero-configuration command-line http server. It is powerful enough for production usage, but it's simple and hackable enough to be used for testing, local development, and learning.

Optionally, we can run webpack to build bundle and simply run `http-server ./dist`
See package.json 'scripts'

# babel-loader
https://webpack.js.org/loaders/babel-loader/

# css-loader
https://github.com/webpack-contrib/css-loader
Allows you to write import / require() to load css files.

# style-loader
https://github.com/webpack-contrib/style-loader
Adds CSS to the dom by injecting style tag inside `<head></head>`

# mini-css-extract-plugin
https://webpack.js.org/plugins/mini-css-extract-plugin/
> This plugin extracts CSS into separate files. It creates a CSS file per JS file which contains CSS. It supports On-Demand-Loading of CSS and SourceMaps.
Moves all required css modules into a separate CSS file. Styles are no longer injected in-line. Combines all required CSS and bundles it creating a single file style.css that is injected. Cannot be used with style-loader or else will error.

# clean-webpack-plugin
https://github.com/johnagan/clean-webpack-plugin
> By default, this plugin will remove all files inside webpack's output.path directory, as well as all unused webpack assets after every successful rebuild.

# html-webpack-plugin
https://github.com/jantimon/html-webpack-plugin
> This is a webpack plugin that simplifies creation of HTML files to serve your webpack bundles. Useful for webpack bundles that contain hash that changes every compilation. Plugin will generate html file for you and inject bundled js file.
***Can also specify favicon here***

App vs Dev vs Peer vs Optional Dependencies

## webpack-dev-server
https://github.com/webpack/webpack-dev-server
> Use webpack with a development server that provides live reloading.
# Run in memory so you won't see the 'dist' folder with the bundle. To see the files in development run 'webpack' command.
It is a development server with webpack that will launch your application on the browser. It will refresh the browser window whenever you change a file.

## Webpack
# https://github.com/webpack/webpack
> webpack is a module bundler. Its main purpose is to bundle JavaScript files for usage in a browser, yet it is also capable of transforming, bundling, or packaging just about any resource or asset
> Webpack is a module bundler.

```
# webpack.config.js

var path = require('path');
var HtmlWebpackPlugin =  require('html-webpack-plugin');

module.exports = {
    entry : './src/index.js',
    output : {
        path : path.resolve(__dirname , 'dist'),
        filename: 'index_bundle.js'
    },
    module : {
        rules : [
            {
              test: /\.m?jsx?$/,
              exclude: /(node_modules|bower_components)/,
              use: {
                loader: 'babel-loader',
                options: {
                  presets: ['@babel/preset-env', '@babel/preset-react']
                }
              }
            },
            {
              test: /\.(sa|sc|c)ss$/i,
              use: ['style-loader', 'css-loader', 'sass-loader'],
            },
        ]
    },
    mode:'development',
    plugins : [
        new HtmlWebpackPlugin ({
            template : './src/public/index.html'
        })
    ]
}
```

# Tell babel compiler we are compiling react and es6 using either .babelrc file or inside package.json or inside webpack.config.js
```
# .babelrc
{
    "presets": [
        "@babel/preset-env",
        "@babel/preset-react"
    ]
}

# package.json
"babel": {
    "presets": [
        "@babel/preset-env",
        "@babel/preset-react"
    ]
},

# webpack.config.js - just after babel-loader
options: {
    presets: ['@babel/preset-env', '@babel/preset-react']
}
```

# html-loader
https://github.com/webpack-contrib/html-loader

## Webpack rules
Rules will apply to given extension specified in 'test'. We want to exclude node_modules. How do we want to transpile the files? We tell webpack to use the babel-loader with preset-env and preset-react. Preset-env allows you to use latest ES6 syntax. Preset-react allows you to use JSX syntax.

What is a transpiler or transcompiler?
> a type of compiler that takes the source code of a program written in a programming language as its input and produces the equivalent source code in the same or a different programming language. - wikipedia

## Support for Sass / Scss files
https://github.com/webpack-contrib/sass-loader
```
yarn add -D sass-loader node-sass
```

## SourceMap
https://webpack.js.org/configuration/devtool/
> Initially it is slow, but it provides fast rebuild speed and yields real files. Line numbers are correctly mapped since it gets mapped to the original code. It yields the best quality SourceMaps for development.
In webpack.config.js add:
```
devtool: 'eval-source-map',
```
Only working in Chrome. Not sure why FF not listing sourceMaps correctly.

# File Loader vs URL Loader
```
yarn add -D file-loader url-loader
```
## Url-Loader
> will encode files to base64 and include them inline rather than having them loaded as separate files with another request.
Ideal for very small files to decrease the number of requests made to the server fetching resources, but will increase your bundle size.
Specify the limit in bytes it will try to url-load the image, if above this threshold, it will by default fallback to file-loader.
[link](https://webpack.js.org/loaders/url-loader/)
data:;base64,aW1wb3J0IFJlYWN0IGZ...
## File-Loader
> will copy files to the build folder and insert links to them where they are included.
[link](https://github.com/webpack-contrib/file-loader)

## webpack-merge
yarn add -D webpack-merge
[link](https://github.com/survivejs/webpack-merge)
> webpack-merge provides a merge function that concatenates arrays and merges objects creating a new object.

## Minification in production
[link](https://webpack.js.org/plugins/mini-css-extract-plugin/#minimizing-for-production)
UglifyJS is a popular older minifier, but today the new kid on the block is terser - an actively maintained fork of Uglify-es. Webpack in production mode minifies using terser by default.
Why minify?
Convert your code into a smaller form that takes up less bytes and loads faster on the browser.
When does a browser know to use the cached version and when to request a new version?

```
yarn add -D terser-webpack-plugin optimize-css-assets-webpack-plugin
```
For documentation
terser-webpack-plugin
[link](https://www.npmjs.com/package/terser-webpack-plugin)
optimize-css-assets-webpack-plugin
[link](https://github.com/NMFR/optimize-css-assets-webpack-plugin)

In the command line:
--optimize-minimize will include TerserPlugin behind the scenes. --define process.env.NODE_ENV="'production'" will do the same for the DefinePlugin. Using the webpack flag -p will do both. Specifying mode also configures DefinePlugin automatically.
See [link](https://webpack.js.org/guides/production/)

-d shortcut for --debug --devtool eval-cheap-module-source-map --output-pathinfo
-p shortcut for --optimize-minimize --define process.env.NODE_ENV="production"
One important caveat: -p sets the NODE_ENV inside your application, but not inside your webpack.config.js, therefore you cannot use conditionals inside your config like process.env.NODE_ENV === 'production' because they will not work. [see](https://github.com/webpack/webpack/issues/2537)

Use webpack [environment variables](https://webpack.js.org/guides/environment-variables/)

# File structure guidelines
public/ static files
src/ files that are imported and changed
How does the browser know to fetch a fresh file or use a cached copy? Webpack renames your files to contain a unique identifier in the filename. That way, if your file changes, the identifier changes and voila, the browser requests the fresh file.

## File structure suggestions
components/ directory put within src/ contains all your components. The folder may contain a header folder with a header.js header.css header.test.js
src/ directory files will contain the entry files to your application. The base component, a general css file, a service-worker.js
assets/ directory to contain sass mixins, images, color schemes, localization files
utils/ directory to contain helper functions used throughout the application
routes/ directory to contain components provided directly to react-routers <Route>s. Components here may import components within the components directory, but components here are best named for *where they are*

<!-- 
Modules
CommonJS module.exports / require
EcmaScript export default / import
 -->

