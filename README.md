# REACT APP EXAMPLE

A React app created without create-react-app that will be used to communicate with my [Rails Api](https://github.com/mariosar/api_example/)

## Steps to reproduce project

```
mkdir react_app_example && cd $_
yarn init -y
yarn add react react-dom
```

Initialize our repository, but first create a .gitignore:
```
touch .gitignore
```
```
# .gitignore
node_modules

# Generated by webpack during compiliation process. Does not need to be committed. Will be generated in production during compilation.
dist
```
```
git init
git add .
git commmit -m "init"
```

## Hello World Example
```
mkdir -p src/public && touch src/index.js src/index.css src/public/index.html
```
```
# index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>React App</title>
</head>
<body>
  <div id="app"></div> 
</body>
</html>

# src/index.js

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';

class App extends React.Component{
    render(){
        return(
            <div>Hello World</div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('app'))
```
We're using JSX syntax, ES6 Syntax. None of this is understood by the browser... yet. We'll use Webpack to bundle our JS. Webpack has a powerful ability to *transform* resources using loaders. We'll use these loaders to convert our ES6 and ReacJSX syntax into bundles that are understood by the browser.

## Dev Dependencies
Add these as dev dependencies - they're dependencies required to develop your app or to build your bundle.
```
yarn add -D @babel/core @babel/preset-env @babel/preset-react
yarn add -D webpack webpack-cli webpack-dev-server babel-loader css-loader style-loader html-webpack-plugin
yarn add -D http-server
```

### Webpack
> webpack is a module bundler. Its main purpose is to bundle JavaScript files for usage in a browser, yet it is also capable of transforming, bundling, or packaging just about any resource or asset [read more](https://github.com/webpack/webpack)

#### babel-loader
> This package allows transpiling JavaScript files using Babel and webpack. [read more](https://webpack.js.org/loaders/babel-loader/)

#### css-loader
> Allows you to write import / require() to load css files. [read more](https://github.com/webpack-contrib/css-loader)

#### style-loader
> Adds CSS to the dom by injecting style tag inside `<head></head>` [read more](https://github.com/webpack-contrib/style-loader)

#### mini-css-extract-plugin
> This plugin extracts CSS into separate files. It creates a CSS file per JS file which contains CSS. It supports On-Demand-Loading of CSS and SourceMaps. [read more](https://webpack.js.org/plugins/mini-css-extract-plugin/)
Moves all required css modules into a separate CSS file. Styles are no longer injected in-line (like in style-loader). 

The benefit is it creates a css file that can be loaded in parallel to the javascript, so is ideal in production. **Note:** Cannot be used with style-loader or else will error.

#### clean-webpack-plugin
> By default, this plugin will remove all files inside webpack's output.path directory, as well as all unused webpack assets after every successful rebuild. [read more](https://github.com/johnagan/clean-webpack-plugin)

This is a handy plugin that will tear down `dist` folder on each build. Remember we added `dist` to our `.gitignore`. This folder is built when we transpile and bundle our application. This plugin will help remove before a new rebuild of our application - just good house cleaning.

#### html-webpack-plugin
> This is a webpack plugin that simplifies creation of HTML files to serve your webpack bundles. Useful for webpack bundles that contain hash that changes every compilation. Plugin will generate html file for you and inject bundled js file. [read more](https://github.com/jantimon/html-webpack-plugin)

Our application isn't just serving a bundled JS file, but an html page *with our bundled js* inside of it. When we move to production builds, we'll often fingerprint our bundled JS to let the browser know to grab a fresh copy instead of using a cached version of our application. How terribly sad it would be if every time we had an update to our production application we had to enter the html file and edit the script url - so lame. This plugin solves that.

#### webpack-dev-server
> Use webpack with a development server that provides live reloading (for development). [read more](https://github.com/webpack/webpack-dev-server)

This is our development server. It runs in memory so you won't see the `dist` folder with the bundle. To see the files in development, you'll want to run `webpack` command. This development server creates a socket with the browser and watches our application files. Whenever there is a change, it will refresh our page. Pretty neat.

#### http-server
> `http-server` is a simple, zero-configuration command-line http server. It is powerful enough for production usage, but it's simple and hackable enough to be used for testing, local development, and learning. [read more](https://www.npmjs.com/package/http-server)

Optionally, we can run `webpack` to build our application and simply run `http-server ./dist`. We may want to run our production build and test it out on our location machine before deployment. http-server is a ready to use tool for that.

### Next Steps
Webpack needs to be told what to do, so we'll create a webpack.config.js file. It does nothing more than export a JS object with some configuration for webpack.
```
touch webpack.config.js
```
```
# webpack.config.js

var path = require('path');
var HtmlWebpackPlugin =  require('html-webpack-plugin');

module.exports = {
    entry : './src/index.js',
    output : {
        path : path.resolve(__dirname , 'dist'),
        filename: 'index_bundle.js'
    },
    module : {
        rules : [
            {
              test: /\.m?jsx?$/,
              exclude: /(node_modules|bower_components)/,
              use: {
                loader: 'babel-loader',
                options: {
                  presets: ['@babel/preset-env', '@babel/preset-react']
                }
              }
            },
            {
              test: /\.(sa|sc|c)ss$/i,
              use: ['style-loader', 'css-loader', 'sass-loader'],
            },
        ]
    },
    mode:'development',
    plugins : [
        new HtmlWebpackPlugin ({
            template : './src/public/index.html'
        })
    ]
}
```

And while we are running webpack and telling it to use the babel-loader on files ending in .js we still need to tell the transpiler that we are compiling React and ES6. There are several ways of doing this:
```
# .babelrc
{
    "presets": [
        "@babel/preset-env",
        "@babel/preset-react"
    ]
}

# package.json
"babel": {
    "presets": [
        "@babel/preset-env",
        "@babel/preset-react"
    ]
},

# webpack.config.js - just after babel-loader
options: {
    presets: ['@babel/preset-env', '@babel/preset-react']
}
```
Good! now our [transpiler](https://en.wikipedia.org/wiki/Source-to-source_compiler) knows our `presets`. You can learn more about cool presets that are out there so you can be on the bleeding edge of all that's happening with JS.

### Webpack Basics

Our webpack has an entry, an output, some rules, a mode, and some plugins. 

The entry tells webpack where to start, what is the root of our application. Webpack supports multiple entries.

The output will be our `dist` folder. Once webpack is completed the work, that's where the bundled js and everything will live.

The rules are a collection of *regex tests* against *file paths* as webpack goes about bundling our code. If the rule is true, then it executes our specified loader that we've attached. **Note:** while rules can return true, we can also exclude certain files. Our `node_modules` have already been transpiled and minified, so we do not need to run our transpiler on them a second time. We've excluded them from our babel-loader. Here we tell webpack to use the babel-loader with preset-env and preset-react. Preset-env allows you to use latest ES6 syntax. Preset-react allows you to use JSX syntax.

Plugins are useful utilities. We've included one that generates the html page required to serve our bundled js file.

## Support for Sass / Scss files
https://github.com/webpack-contrib/sass-loader
```
yarn add -D sass-loader node-sass
```

## SourceMap
https://webpack.js.org/configuration/devtool/
> Initially it is slow, but it provides fast rebuild speed and yields real files. Line numbers are correctly mapped since it gets mapped to the original code. It yields the best quality SourceMaps for development.
In webpack.config.js add:
```
devtool: 'eval-source-map',
```
Only working in Chrome. Not sure why FF not listing sourceMaps correctly.

# File Loader vs URL Loader
```
yarn add -D file-loader url-loader
```
## Url-Loader
> will encode files to base64 and include them inline rather than having them loaded as separate files with another request.
Ideal for very small files to decrease the number of requests made to the server fetching resources, but will increase your bundle size.
Specify the limit in bytes it will try to url-load the image, if above this threshold, it will by default fallback to file-loader.
[link](https://webpack.js.org/loaders/url-loader/)
data:;base64,aW1wb3J0IFJlYWN0IGZ...
## File-Loader
> will copy files to the build folder and insert links to them where they are included.
[link](https://github.com/webpack-contrib/file-loader)

## webpack-merge
yarn add -D webpack-merge
[link](https://github.com/survivejs/webpack-merge)
> webpack-merge provides a merge function that concatenates arrays and merges objects creating a new object.

## Minification in production
[link](https://webpack.js.org/plugins/mini-css-extract-plugin/#minimizing-for-production)
UglifyJS is a popular older minifier, but today the new kid on the block is terser - an actively maintained fork of Uglify-es. Webpack in production mode minifies using terser by default.
Why minify?
Convert your code into a smaller form that takes up less bytes and loads faster on the browser.
When does a browser know to use the cached version and when to request a new version?

```
yarn add -D terser-webpack-plugin optimize-css-assets-webpack-plugin
```
For documentation
terser-webpack-plugin
[link](https://www.npmjs.com/package/terser-webpack-plugin)
optimize-css-assets-webpack-plugin
[link](https://github.com/NMFR/optimize-css-assets-webpack-plugin)

In the command line:
--optimize-minimize will include TerserPlugin behind the scenes. --define process.env.NODE_ENV="'production'" will do the same for the DefinePlugin. Using the webpack flag -p will do both. Specifying mode also configures DefinePlugin automatically.
See [link](https://webpack.js.org/guides/production/)

-d shortcut for --debug --devtool eval-cheap-module-source-map --output-pathinfo
-p shortcut for --optimize-minimize --define process.env.NODE_ENV="production"
One important caveat: -p sets the NODE_ENV inside your application, but not inside your webpack.config.js, therefore you cannot use conditionals inside your config like process.env.NODE_ENV === 'production' because they will not work. [see](https://github.com/webpack/webpack/issues/2537)

Use webpack [environment variables](https://webpack.js.org/guides/environment-variables/)

# File structure guidelines
public/ static files
src/ files that are imported and changed
How does the browser know to fetch a fresh file or use a cached copy? Webpack renames your files to contain a unique identifier in the filename. That way, if your file changes, the identifier changes and voila, the browser requests the fresh file.

## File structure suggestions
components/ directory put within src/ contains all your components. The folder may contain a header folder with a header.js header.css header.test.js
src/ directory files will contain the entry files to your application. The base component, a general css file, a service-worker.js
assets/ directory to contain sass mixins, images, color schemes, localization files
utils/ directory to contain helper functions used throughout the application
routes/ directory to contain components provided directly to react-routers <Route>s. Components here may import components within the components directory, but components here are best named for *where they are*

<!-- 
Modules
CommonJS module.exports / require
EcmaScript export default / import
 -->

## Deploying to Heroku

### Install Heroku CLI
curl https://cli-assets.heroku.com/install-ubuntu.sh | sh
```
heroku login
heroku create
git config --list # Heroku has been added to your remote

yarn add express
touch server.js
```
App vs Dev vs Peer vs Optional Dependencies
